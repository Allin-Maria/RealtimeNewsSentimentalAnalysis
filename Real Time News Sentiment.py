# -*- coding: utf-8 -*-
"""Untitled79.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q6Q1KyA9-1vo8n8FhA_V8LFB3eddeOgL
"""

!pip install streamlit

# -*- coding: utf-8 -*-
"""
Real-Time News Sentiment Dashboard with Streamlit + TextBlob
"""

import os
import time
import uuid
import pandas as pd
import streamlit as st
import plotly.express as px
import requests
from textblob import TextBlob

# Optional fallback news
try:
    from gnews import GNews
except:
    os.system("pip install gnews")
    from gnews import GNews

# ===================== CONFIG =====================
NEWSAPI_KEY = "a009d11222b65976709401fd2ae19baf"  # <-- Replace with your NewsAPI key
PRED_DIR = "predictions_parquet"
os.makedirs(PRED_DIR, exist_ok=True)

# ===================== NEWS FETCHERS =====================
def fetch_news_newsapi(limit=20):
    url = "https://newsapi.org/v2/top-headlines"
    params = {
        "apiKey": NEWSAPI_KEY,
        "language": "en",
        "pageSize": limit
    }
    try:
        r = requests.get(url, params=params, timeout=10)
        r.raise_for_status()
        articles = r.json().get("articles", [])
        rows = []
        for a in articles:
            rows.append({
                "id": a.get("url") or str(uuid.uuid4()),
                "source": (a.get("source") or {}).get("name"),
                "title": a.get("title"),
                "publishedAt": a.get("publishedAt")
            })
        return pd.DataFrame(rows)
    except:
        st.warning("NewsAPI failed. Using GNews fallback.")
        return fetch_news_gnews(limit)

def fetch_news_gnews(limit=20):
    g = GNews(language="en", country="US")
    articles = g.get_top_news()[:limit]
    rows = []
    for a in articles:
        rows.append({
            "id": a.get("url") or str(uuid.uuid4()),
            "source": a.get("source"),
            "title": a.get("title"),
            "publishedAt": a.get("publishedAt")
        })
    return pd.DataFrame(rows)

# ===================== SENTIMENT PREDICTION =====================
def classify_sentiment(df):
    if df.empty:
        return None
    df['sentiment'] = df['title'].apply(lambda t: "Positive" if TextBlob(t).sentiment.polarity > 0 else "Negative")
    df['prob_pos'] = df['title'].apply(lambda t: max(TextBlob(t).sentiment.polarity, 0))
    fname = os.path.join(PRED_DIR, f"pred_{uuid.uuid4().hex}.parquet")
    df.to_parquet(fname, index=False)
    return df

# ===================== DASHBOARD =====================
st.set_page_config(page_title="Real-Time News Sentiment", layout="wide")
st.title("ðŸ“° Real-Time News Sentiment Dashboard")

refresh_interval = st.sidebar.slider("Refresh interval (seconds)", 10, 120, 30)

if st.button("Fetch & Classify Latest News"):
    df_new = fetch_news_newsapi(20)
    out = classify_sentiment(df_new)
    st.success(f"Processed {len(out)} headlines") if out is not None else st.warning("No headlines fetched")

def load_recent(n=200):
    import glob
    files = sorted(glob.glob(os.path.join(PRED_DIR, "*.parquet")), key=os.path.getmtime, reverse=True)[:50]
    if not files:
        return pd.DataFrame(columns=["id","source","title","publishedAt","sentiment","prob_pos"])
    df = pd.concat([pd.read_parquet(f) for f in files], ignore_index=True)
    df = df.drop_duplicates(subset=['id'])
    df['publishedAt'] = pd.to_datetime(df['publishedAt'], errors='coerce')
    return df.sort_values('publishedAt', ascending=False).head(n)

df = load_recent()
st.subheader("Latest Headlines")
st.dataframe(df[['publishedAt','source','title','sentiment','prob_pos']].rename(columns={'title':'headline'}), height=400)

col1, col2 = st.columns([2,1])
with col1:
    st.subheader("Sentiment Distribution")
    if not df.empty:
        counts = df['sentiment'].value_counts().rename_axis('sentiment').reset_index(name='count')
        fig = px.bar(counts, x='sentiment', y='count', color='sentiment', title="Sentiment Distribution")
        st.plotly_chart(fig, use_container_width=True)
with col2:
    st.subheader("Positive Sentiment Trend")
    if not df.empty:
        df_sorted = df.sort_values('publishedAt')
        st.line_chart(df_sorted.set_index('publishedAt')['prob_pos'].fillna(0))

st.markdown(f"**Last updated:** {pd.Timestamp.now()}")

# app.py (Streamlit) - core parts (condensed)
import streamlit as st
import requests
import pandas as pd
from textblob import TextBlob
from gnews import GNews
import pyarrow.parquet as pq
import os
from datetime import datetime
import plotly.express as px

NEWSAPI_KEY = "YOUR_NEWSAPI_KEY" # put your key here

def fetch_news_newsapi(q="technology", api_key=NEWSAPI_KEY, page_size=20):
    url = f"https://newsapi.org/v2/top-headlines?q={q}&pageSize={page_size}&apiKey={api_key}"
    r = requests.get(url, timeout=10)
    if r.status_code == 200:
        data = r.json().get('articles', [])
        return [{'source': a.get('source',{}).get('name'), 'title': a.get('title'), 'publishedAt': a.get('publishedAt')} for a in data]
    else:
        return None

def fetch_news_gnews(q="technology", max_results=20):
    g = GNews(lang='en', max_results=max_results)
    articles = g.get_news(q)
    return [{'source': a.get('publisher'), 'title': a.get('title'), 'publishedAt': a.get('published date')} for a in articles]

def classify_textblob(title):
    polarity = TextBlob(title).sentiment.polarity
    return "Positive" if polarity >= 0 else "Negative", polarity

def save_parquet(df, path="predictions_parquet/preds.parquet"):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    df.to_parquet(path, index=False)

# Streamlit UI (abridged)
st.title("Real-Time News Sentiment Dashboard")

if st.button("Fetch & Classify Latest News"):
    articles = fetch_news_newsapi() or fetch_news_gnews()
    rows = []
    for a in articles:
        sentiment, polarity = classify_textblob(a['title'])
        rows.append({'time': datetime.utcnow().isoformat(), 'source': a.get('source'), 'title': a.get('title'), 'sentiment': sentiment, 'polarity': polarity})
    df = pd.DataFrame(rows)
    save_parquet(df)
    st.dataframe(df)
    fig = px.histogram(df, x='sentiment')
    st.plotly_chart(fig)